##### 基本配置

###### 1、redis.conf配置

- 监听的地址默认是127.0.0.1，限制只可以访问localhost，修改为0.0.0.0或注释掉可以在任意IP访问，不要在prd环境配置为任意IP

    > bind 127.0.0.1

- 守护进程，修改为yes后即可后台运行不用霸屏

    > daemonize no

- 密码，设置后访问redis必须输入密码，默认不需要密码，命令行登录时，需要用`auth`指令手动输入密码

- 可选配置

    - 监听的端口，默认6379

        > port 6379

    - 工作目录，默认当前目录，运行redis-server时的命令，日志、持久化等文件会保存在这个目录

        > dir .

    - 数据库数量，设置为1，代表只使用1个库，默认16个库，编号0-15

        > databases 1

    - 设置redis能够使用的最大内存

        > maxmemory 512mb

    - 日志文件，默认为空，不记录日志，可以指定日志文件名

        > logfile "redis.log"

###### 2、启动Redis

- 进入安装目录`/usr/local/redis-7.0.5`
- 使用配置文件启动`redis-server redis.conf`
- 设置日志文件，记录位置为当前工作目录`redis.log`

###### 3、开机自启

- 新建系统服务文件`vi /etc/systemd/system/redis.service`
- 内容为

> [Unit]
>
> Description=redis-server
>
> After=network.target
>
> 
>
> [Service]
>
> Type=forking
>
> ExecStart=/usr/local/redis-7.0.5/src/redis-server /usr/local/redis-7.0.5/redis.conf
>
> PrivateTmp=true
>
> 
>
> [Install]
>
> WantedBy=multi-user.target

- 重新加载系统服务`systemctl daemon-reload`
- 设置开机自启`systemctl enable redis`



##### 应用

###### 1、缓存更新策略

|          |      |                           内存淘汰                           | 超时剔除                                                  | 主动更新                                   |
| :------: | ---- | :----------------------------------------------------------: | --------------------------------------------------------- | :----------------------------------------- |
|   说明   |      | 不用自己维护，利用Redis的内存淘汰机制，当内存不足时，自动淘汰部分数据。下次查询时更新缓存 | 给缓存添加TTL时间，到期后自动删除缓存。下次查询时更新缓存 | 编写业务逻辑，在修改数据库的同时，更新缓存 |
|  一致性  |      |                              差                              | 一般                                                      | 好                                         |
| 维护成本 |      |                              无                              | 低                                                        | 高                                         |
|          |      |                                                              |                                                           |                                            |

- 低一致性需求：使用内存淘汰机制。如：店铺类型的查询的缓存
- 高一致性需求：主动更新，并以超时剔除作为兜底方案。如：店铺详情查询的缓存

###### 2、主动更新策略

- √ 由缓存的调用者，在更新数据库的同时更新缓存（Cache Aside Pattern）
- × 缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性的问题
- × 调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保证最终一致

###### 3、Cache Aside Pattern

- 删除缓存还是更新缓存
    - √ 删除缓存：更新数据库时让缓存失效，当查询时再更新缓存（先删除缓存，当缓存未命中时再去更新缓存）
    - × 更新缓存：每次更新数据库都更新缓存，无效写操作较多（当只写不查时，更新的缓存就没有意义）
- 如何保证缓存与数据库的操作同时失败或成功（原子性问题）
    - 单体系统：将缓存和数据库操作放在同一个事务中
    - 分布式系统：利用TTC等分布式事务方案
- 更新数据时，先操作缓存还是先操作数据库（线程安全问题）
    - 多线程并发操作缓存和数据库，存在一个交替先后问题
    - 一般采用：先写数据库更新数据，再删除缓存的操作
        - 也会产生数据不一致性，但是概率较先删缓存的操作要低
        - 因为更新数据库的速度较慢，写缓存的速度较快，因此前者的线程不太可能会被中断





##### 缓存穿透

- 指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会直接打在数据库上

###### 1、缓存空对象

- 将不存在的请求数据也缓存到Redis中
- 优点：实现简单，维护方便
- 缺点：额外的内存消耗、可能造成短期的不一致性

###### 2、布隆过滤器

- 在客户端和Redis之间加布隆过滤器进行请求的过滤，如果请求数据存在于过滤器中则放行，不存在则拒绝
- 优点：内存占用较少，没有多余的key
- 缺点：实现复杂、存在误判的可能

###### 3、主动反制手段

- 增强id的复杂度，避免被猜测id规律
- 做好数据的基础格式校验
- 加强用户权限校验
- 做好热点参数的限流



##### 缓存雪崩

- 指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求直接打在数据库上，给数据库带来巨大的压力

###### 1、给不同的key的TTL添加随机值

###### 2、利用Redis集群提高服务的可用性

###### 3、给缓存业务添加降级限流策略

###### 4、给业务添加多级缓存



##### 缓存击穿

- 也称为热点key问题，就是一个被高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击

###### 1、互斥锁

- 查询缓存未命中，线程获取互斥锁并查询数据库开始缓存的重建
- 此时有线程并发执行时，会因为获取互斥锁失败而阻塞
- 直至获得锁的进程重建缓存数据成功，则释放锁

###### 2、逻辑过期

- 不设置某热点数据的TTL，但是在value中写入一个过期时间，当达到过期时间时，意味着该热点数据不再常用，则可以在过期时间上加固定时间作为TTL
- 如果再次启用时，线程查询缓存发现已经过期，则获取互斥锁
- 得到锁之后，开启新线程进行重建缓存，重建完毕后，重置逻辑过期时间释放锁
- 其他线程发现缓存过期且未获得锁时，可以先返回过期的数据

###### 3、方案选择

- 互斥锁：
    - 优点：没有额外的内存消耗、保证一致性、实现简单
    - 缺点：线程需要等待，性能受到影响、可能有死锁的风险
- 逻辑过期：
    - 优点：线程无需等待，性能较好
    - 缺点：不保证一致性、有额外内存消耗、实现复杂
