##### 一、登录模块

###### 1、发送短信验证码

- 生成随机验证码并存放到Redis中，其中key为业务前缀+当前手机号

###### 2、账号登录

- 校验短信验证码
    - 从Redis中取出验证码进行比对
- 通过校验后根据手机号查询用户是否存在
    - 不存在则进行创建
- 随机生成token作为key，并将用户信息作为value以hash的结构存入Redis中
- 登录成功，将验证码从Redis中删除，并向前端返回token
- 前端token放入请求头中，以便后端进行取值

###### 3、自定义拦截器

- 最先定义的拦截器只会拦截用户的登录页面等，如果用户长时间在列表页面，就会导致token的过期，因此需要定义另一个拦截所有路径的拦截器，用来查询用户并刷新token有效期，然后放行到最先定义的拦截器，用来查询ThreadLocal中的用户，存在则不拦截

- 拦截器一：（后定义的）
    - 拦截所有路径
    - 从请求头中获取token，token不存在则放行到第二个拦截器进行拦截
    - 基于token获取Redis中的用户信息，用户不存在则放行到第二个拦截器进行拦截
    - 将Redis中的hash数据转为userDTO对象并存放到ThreadLocal中
- 拦截器二：（最先定义的）
    - 查询ThreadLocal中的用户
    - 有用户则放行，否则拦截
- 总结：第一个拦截器用来存储用户到ThreadLocal，第二个拦截器根据ThreadLocal来拦截
- 在MVCconfig中进行配置
    - 按照添加的顺序执行拦截器
    - 也可以手动设置拦截器的顺序



##### 二、商户模块

###### 1、查询商户并进行缓存（并通过缓存空对象的方式解决缓存穿透问题）

- 根据提交的商户id去查询对应的商户
- 首先查Redis，若缓存命中
    - 空值，则返回404错误
    - 商铺信息，则返回商铺信息

- 缓存未命中则去查询数据库
    - 商户信息存在则将信息存到Redis规定TTL并返回商户信息
    - 商户信息不存在则将空值写入Redis并规定短期的TTL，使无用的空值早点过期，并返回404错误

###### 2、查询商户类型列表并进行缓存

- 同上，存在Redis中的类型也为String，感觉可以优化一下，用List或者ZSet

###### 3、更新商铺

- 查询数据库
- 因为修改了数据库，因此要删除缓存，下次缓存未命中时起到更新缓存的作用
- 单体项目，因此采用@Transactional保证数据库与缓存操作的原子性

###### 4、查询商户并进行缓存（并通过简单的锁的方式解决缓存击穿问题）

- 通过Redis中的“如果无值则新增一个值，有值则不操作”提供的方法，作为锁
- 为了防止意外导致“锁”没有成功释放，可以给“锁”设置TTL，10s左右即可
- 当进程获取到锁时，进行缓存的重建，未获取到锁的进程阻塞
- 重建完毕，释放锁

###### 5、查询商户并进行缓存（并通过逻辑过期的方式解决缓存击穿问题）

- 提前将热点key放入缓存中，可以认为该key会一定命中，如果没有命中，则说明该key不是热点key

- 判断缓存是否命中，若没命中则直接返回空（因此该方案会默认一定会命中）
- 判断缓存是否过期
    - 没有过期则直接返回信息
    - 如果过期则尝试获取锁
        - 获取锁失败则直接返回过期的信息
        - 获取锁成功则开启新线程重建缓存，旧线程直接返回过期的信息
        - 新线程查询数据库写入缓存，并设置逻辑过期时间，最后释放锁

###### 6、基于StringRedisTemplate封装缓存工具类，并满足以下需求

- 存数据：
    - 将任意Java对象序列化成Json并存储在string类型的key中，并且可以设置TTL
    - 将任意Java对象序列化成Json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题
- 取数据：
    - 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
    - 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题



##### 三、优惠券秒杀模块

###### 1、生成全局唯一ID

- 数据库生成的自增id规律简单，容易泄露信息
- 数据库的自增id仅限于当前表，如果进行表的拆分，后续可能会产生重复的情况
- Redis的自增长是针对全局的，但是唯一id需要拼接其他信息以防止信息泄露（如业务前缀等）

###### 2、优惠券秒杀下单

- 查询要下单的优惠券

- 下单时首先判断
    - 秒杀是否开始或结束，否则无法下单
    - 库存是否充足，否则无法下单
- 如条件满足则先扣减库存
- 然后创建对应的订单
- 会同时修改两张表（修改秒杀券的库存和新增优惠券订单），因此需要事务注解

###### 3、超卖问题

- 悲观锁：认为线程安全问题一定会发生，因此在操作数据以前先获取锁，确保线程串行执行
    - 如：Synchronized、Lock
    - 实现简单，但是性能一般
- 乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据进行修改
    - 如果没有修改则认为是安全的，自己才更新数据
    - 如果已经被其他线程修改说明发生了安全问题，此时可以重试或抛异常
    - 性能较高，但是存在成功率低的问题

###### 4、乐观锁

- 版本号法：新增一个字段“版本号”，查询数据的同时查询该数据的版本号，在判断是否更新数据时，先判断版本号是否一致，如果一致则更新，且版本号加1，否则更新失败
- CAS法：直接用更新的字段来充当“版本号”字段，先将更新的数据查询出来，在判断是否更新时，先判断该数据是否跟刚查出来的一致，一致则更新，否则更新失败

###### 5、乐观锁解决超卖问题

- 成功率低的情况：扣减库存时，当且仅当再次查出来的库存量和当前库存量相同时，才进行扣减
    - 假设有100个进程同时查库存，此时100个进程查出来的库存量都是10，只有一个进程能更新成功，其他进程在更新时，发现现库存量不等于10，则不去更新，因此会出现成功率低的情况
- 解决成功率低：扣减库存时，只要再次查出来的库存量大于0即可进行扣减
- 但是乐观锁仍然会访问数据库，因此下面还有优化的方法

###### 6、一人一单

- 即同一个优惠券，一个用户只能下一单
- 判断完库存之后，去查询同一个用户id和用一个券id是否有超过1条即可
- 不能使用乐观锁去解决，因为只是查询而不是更新，乐观锁失效

###### 7、悲观锁解决一人一单问题（以及触发的Spring提交事务失效问题，已Google收藏到书签）

- 因为锁只针对同一个用户，因此`synchronized`关键字可以不用加在方法上，从而缩小锁的范围，提高效率
- ->在`synchronized(userId.toString())`中，`long`类型`toString`的底层实际上还是`new`了`String`，导致每次进来都是新对象，因此可以采用`userId.toString().intern()`来解决，只要常量池里有对应的字符串，就不算新对象
- ->在方法内使用`synchronized(userId.toString().intern())`会出现先释放锁，再提交事务的情况（因为使用了@Transactional，只有在**方法执行完之后**，`Spring`才会帮我们提交事务），即事务没提交并发进程进行获取锁从而引发并发安全问题。因此需要在事务提交之后再去释放锁，即`synchronized(userId.toString().intern())`需要加在调用的函数上
- ->因为调用该函数时，是`this`进行调用的，而非`spring`容器的代理对象进行调用，即产生了自身调用问题造成事务的失效。因此可以拿到`Spring`的代理对象再进行调用即可
- ->获取`Spring`的代理对象法一
    - `Object proxy = AopContext.currentProxy();`
    - 又因为当前实现类的代理对象是其接口，因此可以强转为`IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();`
    - 在`pom`中添加`AspectJ`的依赖
    - 在主启动类上添加`@EnableAspectJAutoProxy(exposeProxy = true)`，暴露代理对象
- ->获取`Spring`的代理对象法二
    - 注入`IVoucherOrderService` ，使用`IVoucherOrderService`来调用函数即可（因为`IVoucherOrderService` 就是该函数的代理对象），即自己注入自己的方式

###### 8、悲观锁的局限性

- 只适用于单体项目
- 当在集群下时，负载均衡会将请求分发到不同的服务器上，而不同的服务器锁的监视器不共享，因此会出现并发安全的问题
- 可以采用分布式锁的方法解决，下面见，芜湖~

###### 9、分布式锁

- 满足分布式系统或集群模式下多进程可见并且互斥的锁

- |        |      | Mysql                     | Redis                    | Zookeeper                        |
    | :----- | ---- | :------------------------ | ------------------------ | :------------------------------- |
    | 互斥   |      | 利用Mysql本身的互斥锁机制 | 利用setnx命令            | 利用节点的唯一性和有序性实现互斥 |
    | 高可用 |      | 好                        | 好                       | 好                               |
    | 高性能 |      | 一般                      | 好                       | 一般                             |
    | 安全性 |      | 断开连接，自动释放锁      | 利用锁超时时间，到期释放 | 临时节点，断开连接自动释放       |
    |        |      |                           |                          |                                  |

