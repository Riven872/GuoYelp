##### 一、登录模块

###### 1、发送短信验证码

- 生成随机验证码并存放到Redis中，其中key为业务前缀+当前手机号

###### 2、账号登录

- 校验短信验证码
    - 从Redis中取出验证码进行比对
- 通过校验后根据手机号查询用户是否存在
    - 不存在则进行创建
- 随机生成token作为key，并将用户信息作为value以hash的结构存入Redis中
- 登录成功，将验证码从Redis中删除，并向前端返回token
- 前端token放入请求头中，以便后端进行取值

###### 3、自定义拦截器

- 最先定义的拦截器只会拦截用户的登录页面等，如果用户长时间在列表页面，就会导致token的过期，因此需要定义另一个拦截所有路径的拦截器，用来查询用户并刷新token有效期，然后放行到最先定义的拦截器，用来查询ThreadLocal中的用户，存在则不拦截

- 拦截器一：（后定义的）
    - 拦截所有路径
    - 从请求头中获取token，token不存在则放行到第二个拦截器进行拦截
    - 基于token获取Redis中的用户信息，用户不存在则放行到第二个拦截器进行拦截
    - 将Redis中的hash数据转为userDTO对象并存放到ThreadLocal中
- 拦截器二：（最先定义的）
    - 查询ThreadLocal中的用户
    - 有用户则放行，否则拦截
- 总结：第一个拦截器用来存储用户到ThreadLocal，第二个拦截器根据ThreadLocal来拦截
- 在MVCconfig中进行配置
    - 按照添加的顺序执行拦截器
    - 也可以手动设置拦截器的顺序



##### 二、商户模块

###### 1、查询商户并进行缓存（并通过缓存空对象的方式解决缓存穿透问题）

- 根据提交的商户id去查询对应的商户
- 首先查Redis，若缓存命中
    - 空值，则返回404错误
    - 商铺信息，则返回商铺信息

- 缓存未命中则去查询数据库
    - 商户信息存在则将信息存到Redis规定TTL并返回商户信息
    - 商户信息不存在则将空值写入Redis并规定短期的TTL，使无用的空值早点过期，并返回404错误

###### 2、查询商户类型列表并进行缓存

- 同上，存在Redis中的类型也为String，感觉可以优化一下，用List或者ZSet

###### 3、更新商铺

- 查询数据库
- 因为修改了数据库，因此要删除缓存，下次缓存未命中时起到更新缓存的作用
- 单体项目，因此采用@Transactional保证数据库与缓存操作的原子性

###### 4、查询商户并进行缓存（并通过简单的锁的方式解决缓存击穿问题）

- 通过Redis中的“如果无值则新增一个值，有值则不操作”提供的方法，作为锁
- 为了防止意外导致“锁”没有成功释放，可以给“锁”设置TTL，10s左右即可
- 当进程获取到锁时，进行缓存的重建，未获取到锁的进程阻塞
- 重建完毕，释放锁

###### 5、查询商户并进行缓存（并通过逻辑过期的方式解决缓存击穿问题）

- 提前将热点key放入缓存中，可以认为该key会一定命中，如果没有命中，则说明该key不是热点key

- 判断缓存是否命中，若没命中则直接返回空（因此该方案会默认一定会命中）
- 判断缓存是否过期
    - 没有过期则直接返回信息
    - 如果过期则尝试获取锁
        - 获取锁失败则直接返回过期的信息
        - 获取锁成功则开启新线程重建缓存，旧线程直接返回过期的信息
        - 新线程查询数据库写入缓存，并设置逻辑过期时间，最后释放锁

###### 6、基于StringRedisTemplate封装缓存工具类，并满足以下需求

- 存数据：
    - 将任意Java对象序列化成Json并存储在string类型的key中，并且可以设置TTL
    - 将任意Java对象序列化成Json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题
- 取数据：
    - 根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
    - 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题



##### 三、优惠券秒杀模块

###### 1、生成全局唯一ID

- 数据库生成的自增id规律简单，容易泄露信息
- 数据库的自增id仅限于当前表，如果进行表的拆分，后续可能会产生重复的情况
- Redis的自增长是针对全局的，但是唯一id需要拼接其他信息以防止信息泄露（如业务前缀等）

###### 2、优惠券秒杀下单

- 查询要下单的优惠券

- 下单时首先判断
    - 秒杀是否开始或结束，否则无法下单
    - 库存是否充足，否则无法下单
- 如条件满足则先扣减库存
- 然后创建对应的订单
- 会同时修改两张表（修改秒杀券的库存和新增优惠券订单），因此需要事务注解

###### 3、超卖问题

- 悲观锁：认为线程安全问题一定会发生，因此在操作数据以前先获取锁，确保线程串行执行
    - 如：Synchronized、Lock
    - 实现简单，但是性能一般
- 乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据进行修改
    - 如果没有修改则认为是安全的，自己才更新数据
    - 如果已经被其他线程修改说明发生了安全问题，此时可以重试或抛异常
    - 性能较高，但是存在成功率低的问题

###### 4、乐观锁

- 版本号法：新增一个字段“版本号”，查询数据的同时查询该数据的版本号，在判断是否更新数据时，先判断版本号是否一致，如果一致则更新，且版本号加1，否则更新失败
- CAS法：直接用更新的字段来充当“版本号”字段，先将更新的数据查询出来，在判断是否更新时，先判断该数据是否跟刚查出来的一致，一致则更新，否则更新失败

###### 5、乐观锁解决超卖问题

- 成功率低的情况：扣减库存时，当且仅当再次查出来的库存量和当前库存量相同时，才进行扣减
    - 假设有100个进程同时查库存，此时100个进程查出来的库存量都是10，只有一个进程能更新成功，其他进程在更新时，发现现库存量不等于10，则不去更新，因此会出现成功率低的情况
- 解决成功率低：扣减库存时，只要再次查出来的库存量大于0即可进行扣减
- 但是乐观锁仍然会访问数据库，因此下面还有优化的方法

###### 6、一人一单

- 即同一个优惠券，一个用户只能下一单
- 判断完库存之后，去查询同一个用户id和用一个券id是否有超过1条即可
- 不能使用乐观锁去解决，因为只是查询而不是更新，乐观锁失效

###### 7、悲观锁解决一人一单问题（以及触发的Spring提交事务失效问题，已Google收藏到书签）

- 因为锁只针对同一个用户，因此`synchronized`关键字可以不用加在方法上，从而缩小锁的范围，提高效率
- ->在`synchronized(userId.toString())`中，`long`类型`toString`的底层实际上还是`new`了`String`，导致每次进来都是新对象，因此可以采用`userId.toString().intern()`来解决，只要常量池里有对应的字符串，就不算新对象
- ->在方法内使用`synchronized(userId.toString().intern())`会出现先释放锁，再提交事务的情况（因为使用了@Transactional，只有在**方法执行完之后**，`Spring`才会帮我们提交事务），即事务没提交并发进程进行获取锁从而引发并发安全问题。因此需要在事务提交之后再去释放锁，即`synchronized(userId.toString().intern())`需要加在调用的函数上
- ->因为调用该函数时，是`this`进行调用的，而非`spring`容器的代理对象进行调用，即产生了自身调用问题造成事务的失效。因此可以拿到`Spring`的代理对象再进行调用即可
- ->获取`Spring`的代理对象法一
    - `Object proxy = AopContext.currentProxy();`
    - 又因为当前实现类的代理对象是其接口，因此可以强转为`IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();`
    - 在`pom`中添加`AspectJ`的依赖
    - 在主启动类上添加`@EnableAspectJAutoProxy(exposeProxy = true)`，暴露代理对象
- ->获取`Spring`的代理对象法二
    - 注入`IVoucherOrderService` ，使用`IVoucherOrderService`来调用函数即可（因为`IVoucherOrderService` 就是该函数的代理对象），即自己注入自己的方式

###### 8、悲观锁的局限性

- 只适用于单体项目
- 当在集群下时，负载均衡会将请求分发到不同的服务器上，而不同的服务器锁的监视器不共享，因此会出现并发安全的问题
- 可以采用分布式锁的方法解决，下面见，芜湖~

###### 9、分布式锁

- 满足分布式系统或集群模式下多进程可见并且互斥的锁

- |        |      | Mysql                     | Redis                    | Zookeeper                        |
    | :----- | ---- | :------------------------ | ------------------------ | :------------------------------- |
    | 互斥   |      | 利用Mysql本身的互斥锁机制 | 利用setnx命令            | 利用节点的唯一性和有序性实现互斥 |
    | 高可用 |      | 好                        | 好                       | 好                               |
    | 高性能 |      | 一般                      | 好                       | 一般                             |
    | 安全性 |      | 断开连接，自动释放锁      | 利用锁超时时间，到期释放 | 临时节点，断开连接自动释放       |
    |        |      |                           |                          |                                  |

###### 10、使用分布式锁解决一人一单问题（v1.0）

- 每台服务器上的进程都会去Redis上获取锁，而非使用自己服务器的锁，保证了锁的多进程可见性
- 使用`stringRedisTemplate.opsForValue().setIfAbsent()`获取锁，且用户的id作为key，来达到“一人一单”的效果
- 获取到锁的进程进行下一步的业务操作，否则返回错误
- 无论业务是否正常结束，都要主动释放锁，因此要try、finally处理

###### 11、解决分布式锁的误删问题（v2.0）

- 在获取锁时，用UUID唯一标识线程
- 释放锁时，与UUID比对
    - 一致则主动释放
    - 不一致则不释放

###### 12、解决分布式锁的误删问题（v3.0）

- 采用Lua脚本，Redis可以原子性的执行完脚本中的指令
- 使判断锁的归属和释放锁原子性的执行

###### 13、优化空间

- 不可重入：同一个线程无法多次获取同一把锁，如方法A和B都需要获取同一把锁，A方法又会调用B方法，就会产生死锁
- 不可重试：获取锁只尝试一次就返回false，没有重试机制
- 超时释放：锁超时释放虽然可以避免死锁，但如果业务执行耗时较长，也会导致锁释放，存在安全隐患
- 主从一致性：如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并未及时进行数据同步，则可能会锁失效

###### 14、Redisson优化锁

- 基本配置
    - 引入依赖
    - 配置Redisson客户端，不推荐使用SpringBoot的starter，会覆盖本身的Redis配置，因此自己配置即可
- 使用
    - 创建锁对象
    - 获取锁
    - 释放锁

###### 15、Redisson锁的方案（原理P-67）

- Redis中不再用简单的String类型存取锁，而是使用Hash结构，用来存储线程id和获取的次数
- Hash结构中没有setnx，因此需要先用exist判断该值是否存在，再决定赋值与否，从而记录获取锁的线程和获取的次数
- 当有线程来获取锁时，判断是否为同一线程，如果是则次数加一，否则不可获取锁，从而达到同一线程可重复获取锁的操作，释放锁时，次数减一即可，当次数为0时，则可以彻底将该线程的锁释放掉
- 底层使用Lua脚本实现
- 原理：
    - 获取锁：尝试获取锁->判断TTL是否为null
        - 否->判断剩余等待时间是否>0
            - 是->订阅并等待释放锁的信息。判断等待时间是否超过自己所剩余的等待时间
                - 是->返回false
                - 否->重新尝试获取锁
            - 否->返回false
        - 是->判断leaseTime是否为-1
            - 是->开启watchDog并返回true
            - 否->返回true
    - 释放锁：尝试释放锁->判断是否成功
        - 否->记录异常
        - 是->发送释放锁的信息。取消watchDog
    - 可重入：利用Hash结构记录线程id和重入次数
    - 可重试：利用信号量和PubSub功能实现等待、唤醒、获取锁失败的重试机制
    - 超时续约：利用watchDog，每隔一段时间，重置超时时间
- multiLock
    - 多个独立的Redis节点，而非一主多从的模式，必须在所有节点都获取可重入锁，才能获取锁成功，避免了在一主多从的情况下，主节点宕机时切换从节点，数据同步被阻塞而造成的数据不一致的问题



##### 四、优惠券秒杀模块优化（提高并发性能）

###### 1、异步秒杀思路：

- Redis的数据结构：
    - 普通的string类型，其中key是优惠券的id，value是当前库存量。
    - 另一个数据结构为set结构，实现不可重复添加数据的特性，可以将成功下单的用户id暂存到value中
- Redis总体用来保存优惠券id、用户id、订单id到阻塞队列
- 服务器用另一个线程异步的去查询优惠券、查询订单、生成创建订单，进行数据库层面的读写操作。异步的读取队列中的信息，完成下单即可
- 开始执行业务，首先执行Lua脚本
    - 判断结果是否为0
        - 是->将优惠券id、用户id和订单id存入到阻塞队列中，并返回订单id（实际创建订单完成）
        - 否->返回异常信息
- 使用Lua脚本保持动作的原子性
    - 判断库存是否充足
        - 是->判断用户是否下单
            - 是->返回2（标识用户重复下单）
            - 否->扣减库存（并不是真正的扣减，而是在Redis减少库存量），并将UserId存入当前优惠券的Set集合，返回0（标识用户下单成功）
        - 否->返回1（标识库存不足）

###### 2、异步秒杀需求：

- 新增秒杀优惠券的同时，将优惠券信息保存到Redis中
- 基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功
- 如果抢购成功，将优惠券id和用户id封装后存入阻塞队列
- 开启线程任务，不断从阻塞队列中获取消息，实现异步下单的功能

###### 3、总结：

- 先利用Redis完成库存余量、一人一单的判断，完成抢单业务
- 再将下单业务放入阻塞队列，利用独立线程异步下单

###### 4、存在的问题：

- 消息队列基于内存建立，存在内存限制、内存溢出的问题
- 存在数据安全的问题，如果已经从队列中取出了消息但是因为异常没有创建单据，则会发生数据丢失



##### 五、Redis消息队列

###### 1、消息队列模型中的三个角色

- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）
- 生产者：发送消息到消息队列
- 消费者：从消息队列获取消息并处理消息

###### 2、与阻塞队列的区别

- MQ不基于内存，实现了数据的持久化
- 消费者处理消息后，MQ会等待消费者的反馈，如果没有反馈则会一直等，直到被消费为止

###### 3、Redis提供了三种不同的方式来实现消息队列

- list结构：基于List结构模拟消息队列
- PubSub（Publish-Subscribe）：基于点对点消息队列
- Stream：比较完善的消息队列模型

###### 4、基于List结构模拟消息队列

- RPOP或LPOP操作时，如果队列中没有消息会返回null。而BRPOP或BLPOP操作时，如果队列中没有元素时，会一直阻塞住连接，直到有新元素加入
- 如生产者用LPUSH往消息队列中添加消息，消费者用BRPOP从消息队列中获取消息，从而达成模拟队列的效果
- 优点：
    - 利用Redis存储，不受限于JVM内存上限
    - 基于Redis的持久化机制，数据安全性有保证
    - 可以满足消息有序性
- 缺点：
    - 无法避免消息丢失
    - 只支持单消费者

###### 5、基于PubSub的消息队列

- 消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息
- 优点：
    - 采用发布订阅模型，支持多生产、多消息
- 缺点：
    - 不支持数据持久化
    - 无法避免消息丢失
    - 消息堆积有上限，超出时数据丢失

###### 6、基于Stream的消息队列（单消费者模式）

- Stream是一种新的数据类型，因此可以支持数据的持久化

- 发送消息的命令

    ```shell
    XADD [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold [LIMIT count]] *|ID field value [field value...]
    
    #NOMKSTREAM 如果队列不存在，是否自动创建队列，默认自动创建
    #MAXLEN|MINID [=|~] threshold [LIMIT count] 设置消息队列的最大容量，默认不设置
    #*|ID 自己指定消息的唯一ID（若选择*表示Redis生成）
    #field value 指定一个或多个Entry键值对 
    
    #如：创建名为users的队列，并向其中发送一个消息，内容为：{name=foo, age=21}，并且使用Redis自动生成id
    命令：XADD users * name foo age 21
    结果："1644085700523-0"
    ```

- 读取消息的命令

    ```shell
    XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key...] ID [ID...]
    
    #COUNT count 每次读取消息的最大数量，默认1
    #BLOCK milliseconds 当没有消息时，是否阻塞、阻塞时长，默认不阻塞
    #key 要从哪个消息队列中读取消息，key就是队列名
    #ID 起始id，只返回大于该ID的消息。其中0表示从第一个消息开始，$表示从最新的消息开始
    
    #如：
    ```

- 漏读消息问题：当我们指定起始ID为$时，代表读取最新的消息，如果我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新一条，会出现漏读消息的问题

- XREAD命令特点：

    - 消息可回溯：消费者使用后消息不会消失 
    - 一个消息可以被多个消费者读取
    - 可以阻塞读取
    - 但是有漏读的风险

###### 7、基于Stream的消息队列（消费者组模式）

- 将多个消费者划分到一个组中，监听同一个队列

    - 消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度（组内是竞争关系）
    - 消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息，确保每一个消息都会被消费（解决漏读问题）
    - 消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list，当处理完成后需要通过XACK来确认消息，标记消息为已处理，才会从pending-list中移除

- 创建消费者组

    ```shell
    XGROUP CREATE key groupName ID [MKSTREAM]
    
    #key：队列名称
    #groupName：消费者组名称
    #ID：起始ID标示，$标示队列中最后一个消息，0则标识队列中第一个消息
    #MKSTREAM：队列不存在时自动创建队列
    
    #其他命令如：
    	#删除指定的消费者组
    	#给指定的消费者组添加消费者
    	#删除消费者组中指定消费者
    ```

- 从消费者组读取消息

    ```shell
    XREADGROUP GROUP group consumer [COUNT count][BLOCK milliseconds][NOACK] STREAMS key [key...] ID [ID...]
    
    #group：消费者组名
    #consumer：消费者名称，如果消费者不存在，会自动创建一个消费者
    #NOACK：无需手动ACK，获取到消息自动确认（不建议使用）
    #ID：获取消息的起始ID：
    #	">"：从下一个未消费的消息开始
    #	其他：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个
    ```

- 特点：

    - 消息可回溯
    - 可以多消费者争抢消息，加快消费速度
    - 可以阻塞读取
    - 没有消息漏读的风险
    - 有消息确认机制，保证消息至少被消费一次

- 大概流程（伪码）：

    ```java
    while(true) {
        //尝试监听队列，使用阻塞模式，最长等待2000毫秒，使用>表示读取下一个未消费的消息
        Object msg = redis.call("XREADGROUP GROUP g1 c1  COUNT 1 BLOCK 2000 STREAMS s1 >");
        //null说明队列中没有消息，continue继续下一次
        if(msg == null) {
            continue;
        }
        try {
            //取到了消息，进行处理，处理完成之后ACK
            handleMsg(msg);
        } catch(Exception e) {
            while(true) {
                //有异常，消息放到pending-list中，已消费但是未确认，因此用0依次取pending-list的消息
                Object msg = redis.call("XREADGROUP GROUP g1 c1  COUNT 1 BLOCK 2000 STREAMS s1 0");
                //null说明没有异常消息，所有消息已经确认，结束循环
                if(msg == null) {
                    break;
                }
                try {
                    //说明有异常消息，再次处理
                    handleMsg(msg);
                } catch(Exception e) {
                    //再次出现异常，记录日志，再次循环
                    continue;
                }
            }
        }
    }
    ```

    

###### 8、基于Redis的Stream结构作为消息队列，实现异步秒杀下单

- 需求：

    - 创建一个Stream类型的消息队列，名为stream.orders

        ```shell
        #创建名为stream.orders的消息队列
        #创建名为g1的消费者组
        #新队列，因此从0开始
        #队列和组不存在时，通过MKSTREAM进行创建
        XGROUP CREATE stream.orders g1 0 MKSTREAM
        ```

    - 修改之前的秒杀下单Lua脚本，在认定有抢购资格之后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId

    - 项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单

    - 下单操作中不必再加锁，只执行扣减库存、创建优惠券订单的数据库IO操作



##### 六、探店模块

###### 1、发布探店笔记

- 上传照片时，会将照片上传到前端服务器
- 保存笔记时，前端已经提交了商铺id、标题、图片、内容，因此在保存时只需要再添加用户id即可

###### 2、查看探店笔记

- 要求返回的数据中，需要包含用户信息，因此可以在Blog实体中，加上所需的用户字段，并加上`@TableField(exist = false)`注解，表明该字段只存在于实体类但不在表中
- 先根据传进来的Blog的id进行查询，得到相应的用户id之后再去查询用户，将查出来的用户信息赋值到Blog中，再次返回有用户信息的Blog即可

###### 3、点赞

- 同一个用户只能点赞一次，再次点击则取消点赞
- 如果当前用户已经点赞，则点赞按钮高亮显示（前端已经实现，判断字段Blog类的isLike属性）
- 步骤
    - Blog类中新增一个isLike的字段（数据库中并没有），标示是否被当前用户点赞
    - 修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1
    - 判断当前用户是否点赞过，赋值给isLike字段
        - 根据id查询blog详情时
        - 分页查询blog时

###### 4、点赞排行榜

- 要求按点赞时间先后排序，并且用户只能点赞一次，因此可选用SortedSet数据结构，因此点赞时的点赞数需要往SortedSet中去存放，并用时间戳当分数
- 判断用户是否点赞，只需要获取当前用户的分数，如果分数为空，则说明没有点赞
- 取出前5名或指定名次作为排行榜展示



##### 七、好友关注模块

###### 1、关注和取关

- 关注是User之间的关系，可以表示为多对多，因此需要一张中间表用来存放用户id和关联的用户id
- 关注就是往中间表中新增登录用户信息和关注人的信息
- 取关就是将含有登录用户信息和关注人的信息的数据删除即可

###### 2、共同关注

- 点击博主头像，进入博主首页
    - 需要查询博主的用户信息：名字、头像、简介
    - 需要查询博主发布的笔记
- 进入共同关注tab，求当前登录用户与指定用户关注的交集
    - 可以使用Redis中的set数据结构中的SINTER求交集
    - 将登录用户与指定用户的关注对象放到Redis中
        - 关注时，不仅仅修改数据库，还将关注用户存到Redis中
        - key为登录用户id，value为关注的用户id
        - 取关时，从Redis中删除数据即可

###### 3、关注推送（Feed流）

- 两种常见的模式

    - 1、TimeLine：根据内容发布时间排序，只进行好友或关注这样简单筛选
        - 优点：信息全面，不会有缺失，并且实现也相对简单
        - 缺点：用户不一定感兴趣，内容获取效率低
    - 2、智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣的信息来吸引用户
        - 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷
        - 缺点：如果算法不精准，可能起到反作用

- TimeLine实现方案：

    - 拉模式：读扩散模式（读信息时有延迟）
    - 推模式：写扩散模式（发信息时有高空间占用）
    - 推拉结合模式：混合模式

- ###### 4、推模式实现关注推送功能

    - 在新增探店笔记时，保存blog到数据库的同时也推送到粉丝的收件箱中
    - 收件箱可满足可以根据时间戳排序
    - 查询收件箱数据时，可以实现分页查询
        - Feed流中数据是不断更新的，因此不能采用传统的分页模式
        - 可以采用滚动分页，即每次查询完之后，记录最后一条查到的信息的下标，即使有信息插入也不影响，下次查询时以上次标记的为基准
        - SortedSet可以实现按分数的范围进行查询，而List结构只能用下标查询，因此可以将时间戳当做分数，使用SortedSet数据结构
        - 滚动分页查询参数
            - Max：当前时间戳或上一次查询的最小时间戳作为下一次查询的最大值
            - Min：0
            - Offset：0或在上一次的结果中，与最小值一样的元素的个数
            - Count：每页展示的数量，定值



